// automatically generated by Xtext
grammar org.palladiosimulator.supporting.prolog.Prolog hidden(WS)

import "http://palladiosimulator.org/supporting/prolog/0.1.0"
// see https://sdqweb.ipd.kit.edu/wiki/Importing_nested_EPackages_in_Xtext
//import "http://palladiosimulator.org/supporting/prolog/expressions/0.1.0" as expressions
//import "http://palladiosimulator.org/supporting/prolog/directives/0.1.0" as directives
import "platform:/resource/org.palladiosimulator.supporting.prolog.model/model/prolog.ecore#//expressions" as expressions
import "platform:/resource/org.palladiosimulator.supporting.prolog.model/model/prolog.ecore#//directives" as directives
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
   Information used to create this grammar:
   * Predicates precedence and associativity
     * https://www.swi-prolog.org/pldoc/man?predicate=op/3
     * https://www-users.york.ac.uk/~sjh1/courses/L334css/complete/complete2/node25.html
   * Design of expression languages
     * https://www.typefox.io/blog/parsing-expressions-with-xtext
     * https://dslmeinte.wordpress.com/2011/03/24/more-on-pre-and-postfix-operators-in-xtext/
  
   Known limitations:
   * No support for := and ** and ? operator because their meaning is unclear
   * Deprecated | operator not supported but ; is
   * Only expressions starting with precedence 900 and associativity fy are supported in terms
   * There is no dedicated meta class for atoms but CompoundTerm has to be used
   * 
 */

Program:
	clauses+=Clause*
;

Clause:
	((Predicate | TermClause) '.') | Comment
;

Comment:
	value=PROLOG_SL_COMMENT
;

Predicate returns Clause:
	':-' (TableDirective | ListDirectives)
;

TableDirective returns directives::Table:
	'table' '(' predicate=PredicateIndicator ')' 
;

ListDirectives returns directives::Directive:
	(
		({directives::Dynamic} name='dynamic') |
		({directives::Discontiguous} name='discontiguous') |
		({directives::Multifile} name='multifile') |
		({directives::Public} name='public') |
		({directives::Volatile} name='volatile')
	)
	'(' predicates+=PredicateIndicator (',' predicates+=PredicateIndicator)* ')'
;

PredicateIndicator returns directives::PredicateIndicator:
	name=(PROLOG_ID|PROLOG_STRING) '/' arity=INT
;

TermClause returns Clause:
	CompoundTerm (
		({Fact.head=current}) |
		({Rule.head=current} ':-' body=Expression_1100_xfy)
	)
;

Term:
	CompoundTerm | AtomicNumber | AtomicDouble | /*AtomicID |*/ AtomicQuotedString | List | ControlPredicate
;

CompoundTerm:
	value=PROLOG_ID ('(' arguments+=Expression_900_fy (',' arguments+=Expression_900_fy)* ')')?
;

AtomicNumber:
	value=INT
;

AtomicDouble:
	value=Double
;

Double returns ecore::EDouble:
	INT '.' INT
;

AtomicQuotedString:
	value=PROLOG_STRING
;

//AtomicID:
//	value=PROLOG_ID
//;

List:
	{List} '['
	(
		heads+=Expression_900_fy (',' heads+=Expression_900_fy)*
		(
			'|' tails+=Expression_900_fy (',' tails+=Expression_900_fy)*
		)?
	)? ']'
;

ControlPredicate: 
	True | False | Fail | Cut
;

True:
	 {True} 'true'
;

False:
	{False} 'false'
;

Fail:
	{Fail} 'fail'
;

Cut:
	{Cut} '!'
;

// logical OR, 1100, infix, left-associative
Expression_1100_xfy returns expressions::Expression:
	Expression_1050_xfy ({expressions::LogicalOr.left=current} /*(';'|'|')*/ ';' right=Expression_1050_xfy)*
;


// IF-THEN, 1050, infix, left-associative 
Expression_1050_xfy returns expressions::Expression:
	Expression_1000_xfy (
		(
			({expressions::Condition.left=current} '->') |
			({expressions::SoftCut.left=current} '*->')
		) 
		right=Expression_1000_xfy
	)*
;

// logical AND, 1000, infix, left-associative
Expression_1000_xfy returns expressions::Expression:
	Expression_900_fy ({expressions::LogicalAnd.left=current} ',' right=Expression_900_fy)*
;

// 990, infix, non-associative
/*
Expression_990_xfx returns Expression:
	Expression_900_fy ({Expression_990_xfx.left=current} ':=' right=Expression_900_fy)?
;
*/

// NOT_PROVABLE, 900, prefix, right-associative
Expression_900_fy returns expressions::Expression:
	Expression_700_xfx | ({expressions::NotProvable} '\\+' expr=Expression_900_fy)
;

// COMPARISONS, 700, infix, non-associative
Expression_700_xfx returns expressions::Expression:
	Expression_600_xfy (
		(
			({expressions::LessThan.left=current} '<') |
			({expressions::Unification.left=current} '=') |
			({expressions::Univ.left=current} '=..') |
			({expressions::StructuralEquivalence.left=current} '=@=') |
			({expressions::StructuralEquivalenceNotProvable.left=current} '\\=@=') |
			({expressions::NumberEqual.left=current} '=:=') |
			({expressions::LessOrEqual.left=current} '=<')  |
			({expressions::Equivalence.left=current} '==')  |
			({expressions::NonEqualNumber.left=current} '=\\=')  |
			({expressions::GreaterThan.left=current} '>')  |
			({expressions::GreaterOrEqual.left=current} '>=')  |
			({expressions::StandardOrderBefore.left=current} '@<')  |
			({expressions::EqualOrStandardOrderBefore.left=current} '@=<')  |
			({expressions::StandardOrderAfter.left=current} '@>')  |
			({expressions::EqualOrStandardOrderAfter.left=current} '@>=')  |
			({expressions::NotUnifiable.left=current} '\\=')  |
			({expressions::Disequality.left=current} '\\==')  |
			({expressions::As.left=current} 'as')  |
			({expressions::Is.left=current} 'is')  |
			({expressions::ParticalUnification.left=current} '>:<')  |
			({expressions::SubDict.left=current} ':<')
		) 
		right=Expression_600_xfy)?
;

// 600, infix, right-associative
Expression_600_xfy returns expressions::Expression:
 	Expression_500_yfx ({expressions::ModuleCall.left=current} ':' right=Expression_600_xfy)?
;

// 500, infix, left-associative
Expression_500_yfx returns expressions::Expression:
	Expression_400_yfx (
		(
			({expressions::Plus.left=current} '+') |
			({expressions::Minus.left=current} '-') |
			({expressions::BinaryAnd.left=current} '/\\') |
			({expressions::BinaryOr.left=current} '\\/') |
			({expressions::Xor.left=current} 'xor')
		)
		right=Expression_400_yfx)*
;

// 500, prefix, non-associative
/*
Expression_500_fx returns expressions::Expression:
	Expression_400_yfx | ('?' expr=Expression_400_yfx)
;
*/

// 400, infix, left-associative
Expression_400_yfx returns expressions::Expression:
	Expression_200_xfy (
		(
			({expressions::Multiplication.left=current} '*') |
			({expressions::Division.left=current} '/') |
			({expressions::IntegerDivision.left=current} '//') |
			({expressions::Div.left=current} 'div') |
			({expressions::Rdiv.left=current} 'rdiv') |
			({expressions::BitwiseShiftLeft.left=current} '<<') |
			({expressions::Mod.left=current} 'mod') |
			({expressions::Rem.left=current} 'rem')
		)
		right=Expression_200_xfy)*
;

// 200, infix, non-associative
/*
Expression_200_xfx returns Expression:
	Expression_200_xfy ({Expression_200_xfx.left=current} '**' right=Expression_200_xfy)?
;
*/

// 200, infix, right-associative
Expression_200_xfy returns expressions::Expression:
	Expression_200_fy ({expressions::Power.left=current} '^' right=Expression_200_xfy)?
;

// 200, prefix, right-associative
Expression_200_fy returns expressions::Expression:
	Expression_Primary | (
		(
			({expressions::PositiveNumber} '+') |
			({expressions::NegativeNumber} '-') |
			({expressions::BitwiseNegation} '\\')
		) 
		expr=Expression_200_fy
	)
;

Expression_Primary returns expressions::Expression:
	'(' Expression_1100_xfy ')' | Term
;

terminal PROLOG_ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal PROLOG_STRING: "'" (!"'" )* "'";
terminal PROLOG_SL_COMMENT : '%' !('\n'|'\r')* ('\r'? '\n')?;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal WS         : (' '|'\t'|'\r'|'\n')+;